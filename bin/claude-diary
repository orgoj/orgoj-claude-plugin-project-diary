#!/usr/bin/env bash
# claude-diary - Wrapper for Claude Code with automatic diary management
#
# Features:
# - Generates session ID for continuity
# - Detects unprocessed diaries and offers /reflect
# - Offers /diary at session end (runs in same session via --resume)
# - Auto-mode support via config
# - Permissions setup for automated commands
# - Minimum session size check (skips diary for small sessions)

set -e

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Parse wrapper arguments (before --)
WRAPPER_MIN_SIZE=""
WRAPPER_AUTO_DIARY=""
WRAPPER_AUTO_REFLECT=""
CLAUDE_ARGS=()
PARSING_WRAPPER=true

for arg in "$@"; do
  if [ "$PARSING_WRAPPER" = true ]; then
    case "$arg" in
      --min-session-size)
        shift
        WRAPPER_MIN_SIZE="$1"
        shift
        continue
        ;;
      --auto-diary)
        WRAPPER_AUTO_DIARY="true"
        shift
        continue
        ;;
      --auto-reflect)
        WRAPPER_AUTO_REFLECT="true"
        shift
        continue
        ;;
      --)
        PARSING_WRAPPER=false
        shift
        continue
        ;;
      *)
        # Not a wrapper arg, stop parsing wrapper options
        PARSING_WRAPPER=false
        ;;
    esac
  fi

  # Collect Claude CLI arguments
  if [ "$PARSING_WRAPPER" = false ]; then
    CLAUDE_ARGS+=("$arg")
  fi
done

# Generate unique session ID (8 chars)
SESSION_ID=$(head -c 6 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)

# Locate project root (find .claude directory)
PROJECT_ROOT="$(pwd)"
while [ "$PROJECT_ROOT" != "/" ]; do
  if [ -d "$PROJECT_ROOT/.claude" ]; then
    break
  fi
  PROJECT_ROOT="$(dirname "$PROJECT_ROOT")"
done

if [ ! -d "$PROJECT_ROOT/.claude" ]; then
  PROJECT_ROOT="$(pwd)"
fi

DIARY_DIR="$PROJECT_ROOT/.claude/diary"
CONFIG_FILE="$DIARY_DIR/.config.json"

# Load wrapper config
if [ -f "$CONFIG_FILE" ]; then
  AUTO_DIARY=$(jq -r '.wrapper.autoDiary // false' "$CONFIG_FILE" 2>/dev/null || echo "false")
  AUTO_REFLECT=$(jq -r '.wrapper.autoReflect // false' "$CONFIG_FILE" 2>/dev/null || echo "false")
  ASK_DIARY=$(jq -r '.wrapper.askBeforeDiary // true' "$CONFIG_FILE" 2>/dev/null || echo "true")
  ASK_REFLECT=$(jq -r '.wrapper.askBeforeReflect // true' "$CONFIG_FILE" 2>/dev/null || echo "true")
  MIN_SESSION_SIZE=$(jq -r '.wrapper.minSessionSize // 2' "$CONFIG_FILE" 2>/dev/null || echo "2")
else
  # Defaults if no config
  AUTO_DIARY="false"
  AUTO_REFLECT="false"
  ASK_DIARY="true"
  ASK_REFLECT="true"
  MIN_SESSION_SIZE="2"
fi

# Override with CLI arguments
if [ -n "$WRAPPER_AUTO_DIARY" ]; then
  AUTO_DIARY="$WRAPPER_AUTO_DIARY"
fi
if [ -n "$WRAPPER_AUTO_REFLECT" ]; then
  AUTO_REFLECT="$WRAPPER_AUTO_REFLECT"
fi
if [ -n "$WRAPPER_MIN_SIZE" ]; then
  MIN_SESSION_SIZE="$WRAPPER_MIN_SIZE"
fi

# Setup temporary permissions for automated commands
TEMP_SETTINGS="$PROJECT_ROOT/.claude/settings.local.json"
cat > "$TEMP_SETTINGS" <<EOF
{
  "allowedTools": [
    "SlashCommand(/diary)",
    "SlashCommand(/reflect)",
    "SlashCommand(/diary-config)",
    "Edit",
    "Write",
    "Read",
    "Glob",
    "Grep",
    "Bash(git *)",
    "Bash(jq *)",
    "Bash(find *)",
    "Bash(mkdir *)",
    "Bash(cat *)"
  ]
}
EOF

# Cleanup function
cleanup() {
  rm -f "$TEMP_SETTINGS"
}
trap cleanup EXIT

# Check for unprocessed diary entries (not recovery files)
check_unprocessed() {
  local count=0

  if [ -d "$DIARY_DIR" ]; then
    count=$(find "$DIARY_DIR" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l)
  fi

  echo $count
}

# Check session size (transcript filesize in KB)
check_session_size() {
  local session_id="$1"

  # Find transcript in ~/.claude/projects/
  local project_name=$(echo "$PROJECT_ROOT" | sed 's|/|-|g')
  local transcript_path="$HOME/.claude/projects/${project_name}/${session_id}.jsonl"

  if [ ! -f "$transcript_path" ]; then
    echo "0"
    return
  fi

  # Get size in KB
  local size_kb=$(du -k "$transcript_path" 2>/dev/null | cut -f1)
  echo "${size_kb:-0}"
}

# Main flow
echo -e "${BLUE}üöÄ Claude Diary Wrapper${NC}"
echo -e "${BLUE}   Session ID: ${SESSION_ID}${NC}"
echo ""

# [1] Check for unprocessed diaries
UNPROCESSED_COUNT=$(check_unprocessed)

if [ "$UNPROCESSED_COUNT" -gt 0 ]; then
  echo -e "${YELLOW}üìö Found ${UNPROCESSED_COUNT} unprocessed diary file(s)${NC}"

  RUN_REFLECT=false

  if [ "$AUTO_REFLECT" = "true" ]; then
    RUN_REFLECT=true
    echo -e "${GREEN}üîÑ Auto-running /reflect...${NC}"
  elif [ "$ASK_REFLECT" = "true" ]; then
    read -p "Run /reflect to process them? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      RUN_REFLECT=true
    fi
  fi

  if [ "$RUN_REFLECT" = "true" ]; then
    claude code /reflect
    echo ""
  fi
fi

# [2] Run main Claude session with session ID
echo -e "${GREEN}üí¨ Starting Claude Code session...${NC}"
echo ""

claude code --session-id "$SESSION_ID" "${CLAUDE_ARGS[@]}"

# [3] After session ends - check session size and offer /diary
echo ""
echo -e "${BLUE}üìù Session ended${NC}"

# Check transcript size
SESSION_SIZE=$(check_session_size "$SESSION_ID")
echo -e "${BLUE}   Transcript size: ${SESSION_SIZE} KB (min: ${MIN_SESSION_SIZE} KB)${NC}"

if [ "$SESSION_SIZE" -lt "$MIN_SESSION_SIZE" ]; then
  echo -e "${YELLOW}‚è© Session too small, skipping diary${NC}"
  echo ""
  echo -e "${GREEN}‚ú® Done!${NC}"
  exit 0
fi

# Session is large enough - offer diary
RUN_DIARY=false

if [ "$AUTO_DIARY" = "true" ]; then
  RUN_DIARY=true
  echo -e "${GREEN}üìù Auto-running /diary...${NC}"
elif [ "$ASK_DIARY" = "true" ]; then
  read -p "Create diary for this session? [Y/n] " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Nn]$ ]]; then
    RUN_DIARY=true
  fi
fi

if [ "$RUN_DIARY" = "true" ]; then
  echo ""
  claude code --resume "$SESSION_ID" /diary
fi

echo ""
echo -e "${GREEN}‚ú® Done!${NC}"
